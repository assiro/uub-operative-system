  // This file is a generated sample test application.
  // 
  // This application is intended to test and/or illustrate some functionality
  // of your system. The contents of this file may vary depending on the IP in
  // your system and may use existing IP driver functions. These drivers will 
  // be generated in your SDK application project when you run the "Generate 
  // Libraries" menu item. 
  
 #include <stdio.h>
 #include "xparameters.h"
 #include "xil_cache.h"
 #include "xscugic.h"
 #include "xil_exception.h"
 #include "scugic_header.h"
 #include "uartlite_header.h"
 #include "xdevcfg.h"
 #include "devcfg_header.h"
 #include "xdmaps.h"
 #include "dmaps_header.h"
 #include "xemacps.h"
 #include "xemacps_example.h"
 #include "emacps_header.h"
 #include "xiicps.h"
 #include "iicps_header.h"
 #include "xqspips.h"
 #include "qspips_header.h"
 #include "xscutimer.h"
 #include "scutimer_header.h"
 #include "xscuwdt.h"
 #include "scuwdt_header.h"
 #include "xspips.h"
 #include "spips_header.h"
 #include "xuartps.h"
 #include "uartps_header.h"
 #include "xuartlite.h"
 #include "new_uub.h"
 
 #define true  1
 #define false 0
 extern XUartLite UartLite;      /* Instance of the UartLite device */
 
 int main() 
 {
    static XScuGic intc;
    static XEmacPs ps7_ethernet_0;
    static XScuTimer ps7_scutimer_0;
    static XScuWdt ps7_scuwdt_0;
    static XUartPs ps7_uart_0;
    Xil_ICacheEnable();
    Xil_DCacheEnable();
    int Status,i;
    

    print(" ***************************************************\n\r");
    print(" ***                 WP1 RUN Process             ***\n\r");
    print(" ***************************************************\n\r");
    {
          int data_display;
          unsigned int *state_register;
          state_register = UUB_STATE_REGISTER; // state register in test_uub module
       }

    {
       print("\r\n Test of the GPS UART link ............... : ");
       Status = UartLiteSelfTestExample(XPAR_AXI_UARTLITE_0_DEVICE_ID);
       SendPassFail(Status);
    }
      
  // Initialisation : 
  //        - du circuit clock generateur CDEL913   
  //        - des circuits ADC AD9628
  //        - du quad DAC AD5316 LED CONTROLER
    {
      int tst_enable ;
      
 
      // initialise le circuit clock generator CDEL913
      print("\r\n Initialization of I2C clock generator ... : ");
      XIicPs_ResetHw(XPAR_XIICPS_1_BASEADDR);
      Status = IicPsInitClockGenerator(XPAR_PS7_I2C_1_DEVICE_ID);
      SendPassFail(Status);
  
      // initialise le cleaner Jitter
      print(" Initialization of Jitter Cleaner ........ : ");
      Status = IicPsInitJitterCleaner(XPAR_PS7_I2C_1_DEVICE_ID);
      SendPassFail(Status);
      
      // initialise les circuits ADC9628
       print(" Initialization of ADC 9628 .............. : ");
       Status = SpiPs_Init_SPI(XPAR_PS7_SPI_0_DEVICE_ID, 0);
       SendPassFail(Status);
 
      // Initialize the Quad DAC chip AD5316
       
       print(" Initialization of DAC AD5316 ............ : ");
       XIicPs_ResetHw(XPAR_XIICPS_0_BASEADDR);
       Status = IicPsInitI2C0(XPAR_PS7_I2C_0_DEVICE_ID);
       SendPassFail(Status);
    }
    
    //* Test will not be run for ps7_uart_1 because it was the STDOUT device

    //*********************************************************************
    // Access test to GPS sub systems :
    //   - Send data to the GPS UART and test if the UART receive them 
    //     throught a feed back
    //*********************************************************************
    
    u8 RadioSdDat[4] = {0x41,0x42,0x43,0x44};
    u8 RadioRvDat[4] = {0x00,0x00,0x00,0x00};
    int data_display;
    unsigned int *state_register;
       
    XUartLite_ResetFifos(&UartLite);
    XUartLite_Send(&UartLite,RadioSdDat,4);
    print(" UART GPS loop test ...................... : ");
    XUartLite_Recv(&UartLite,RadioRvDat,4);
    if ((RadioSdDat[0] == RadioRvDat[0]) && (RadioSdDat[1] == RadioRvDat[1]) && 
         (RadioSdDat[2] == RadioRvDat[2]) && (RadioSdDat[3] == RadioRvDat[3]) )  
    { Status = XST_SUCCESS;}  
    else
    { 
        Status = XST_FAILURE;
        printf("%x %x %x %x %x %x %x %x    ",RadioSdDat[0],RadioSdDat[1],
                                             RadioSdDat[2],RadioSdDat[3],
                                             RadioRvDat[0],RadioRvDat[1],
                                             RadioRvDat[2],RadioRvDat[3]);
    }
    
    SendPassFail(Status);

    print("\n\r ***  END START UP  ***\n\r\n");


//   Status = SpiPs_Init_SPI(XPAR_PS7_SPI_1_DEVICE_ID, 0);	// funzione di setup_ADC
//   SendADCData();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Lettura BRAM canali ADC0 e ADC1
    unsigned int *bram0, *bram1, *bram2, *bram3, *bram4, *int_trig;
    bram0 = 0x42000000;	// ADC 1
    bram1 = 0x44000000; // ADC 2
    bram2 = 0x46000000;	// ADC 3
    bram3 = 0x48000000; // ADC 4
    bram4 = 0x4A000000;	// ADC 5

    int w, z, x, y,j ,h, ADC0A, ADC0B, ADC1A, ADC1B, ADC2A, ADC2B, ADC3A, ADC3B, ADC4A, ADC4B;
    int_trig = 0x41200000;
    *int_trig = 0x000000FF;//acquisisco segnale in BRAM
    usleep(1);
    *int_trig = 0x00000000;

//*bram0 = 0x1FFF1FFF;// scrivo prima loc bram per prova
    print("        ADC1        |         ADC2        |         ADC3        |         ADC4        |         ADC5        |\r\n");

//	GpioPolledExample(GPIO_DEVICE_ID, &InputData);// invio ASY_TRIG su led driver
//	XUartPs_Send(&Uart_Ps, "UUB", 3);// invio header trasmissione seriale
//  print("UUB");// invio header trasmissione seriale
    for ( w = 0; w < 20; w++) //numero dilocazioni BRAM da inviare su seriale.
    //for ( w = 513; w < 1027; w++) //numero dilocazioni BRAM da inviare su seriale.
    //for ( w = 100; w < 613; w++) //numero dilocazioni BRAM da inviare su seriale.
           {
    	   ADC0A = *bram0;
           ADC0B = *bram0&0xfff;
           ADC1A = *bram1;
           ADC1B = *bram1&0xfff;
    	   ADC2A = *bram2;
           ADC2B = *bram2&0xfff;
           ADC3A = *bram3;
           ADC3B = *bram3&0xfff;
    	   ADC4A = *bram4;
           ADC4B = *bram4&0xfff;
           y = (ADC0A>>16)&0xfff;
           x = (ADC1A>>16)&0xfff;
           z = (ADC2A>>16)&0xfff;
           j = (ADC3A>>16)&0xfff;
           h = (ADC4A>>16)&0xfff;
//           printf("chA = %D chB = %D | chA = %D chB = %D | chA = %D chB = %D | chA = %D chB = %D | chA = %D chB = %D\r\n", y, ADC0B, x, ADC1B, z, ADC2B, j, ADC3B, h, ADC4B);
           printf("chA = %X chB = %X | chA = %X chB = %X | chA = %X chB = %X | chA = %X chB = %X | chA = %X chB = %X\r\n", y, ADC0B, x, ADC1B, z, ADC2B, j, ADC3B, h, ADC4B);

      //     	printf( " Cha. A = %5D, Cha. B = %5D",data_display & 0xffff,data_display >>16);

//           XUartPs_Send(&Uart_Ps2, &y, 2);
//           usleep(3000);
//           	print(&ADC0B);
//           XUartPs_Send(&Uart_Ps2, &ADC0B, 2);
//           usleep(5000);

           bram0 ++;
           bram1 ++;
           bram2 ++;
           bram3 ++;
           bram4 ++;

           }

           print("\n\r ***  Fine invio dati  ***\n\r");
//    XUartPs_Send(&Uart_Ps, "Fine invio dati...\n", 19);



    Xil_DCacheDisable();
    Xil_ICacheDisable();
    return 0;
 }
 
 //***********************************************************************
 //     Send PASSED or FAILLED to the console depend of STATUS value
 //***********************************************************************

 int SendPassFail(Status)
 {
   if (Status == 0) { print("passed\r\n"); } else { print("failed\r\n"); }
   return XST_SUCCESS;
 }


     
